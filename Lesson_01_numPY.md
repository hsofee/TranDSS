# ‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏≠‡∏ô NumPy
## ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏õ‡∏£‡∏¥‡∏ç‡∏ç‡∏≤‡∏ï‡∏£‡∏µ ‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏π‡∏ï‡∏£‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ò‡∏∏‡∏£‡∏Å‡∏¥‡∏à‡πÅ‡∏•‡∏∞‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡∏î‡∏¥‡∏à‡∏¥‡∏ó‡∏±‡∏•
## ‡∏≠.‡πÇ‡∏ã‡∏ü‡∏µ‡∏£‡πå ‡∏´‡∏∞‡∏¢‡∏µ‡∏¢‡∏π‡πÇ‡∏ã‡πä‡∏∞

---

## üìö ‡∏™‡∏≤‡∏£‡∏ö‡∏±‡∏ç
1. [‡∏ö‡∏ó‡∏ô‡∏≥ NumPy](#‡∏ö‡∏ó‡∏ô‡∏≥-numpy)
2. [‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£ Import](#‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£-import)
3. [NumPy Array ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô](#numpy-array-‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô)
4. [‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Array](#‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á-array)
5. [Array Indexing ‡πÅ‡∏•‡∏∞ Slicing](#array-indexing-‡πÅ‡∏•‡∏∞-slicing)
6. [‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≤‡∏á‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå](#‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≤‡∏á‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå)
7. [Array Manipulation](#array-manipulation)
8. [Broadcasting](#broadcasting)
9. [‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç](#‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç)
10. [Linear Algebra](#linear-algebra)
11. [Random Numbers](#random-numbers)
12. [File I/O](#file-io)
13. [Performance ‡πÅ‡∏•‡∏∞ Memory](#performance-‡πÅ‡∏•‡∏∞-memory)
14. [‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î](#‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î)
15. [‡πÇ‡∏Ñ‡∏£‡∏á‡∏á‡∏≤‡∏ô‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥](#‡πÇ‡∏Ñ‡∏£‡∏á‡∏á‡∏≤‡∏ô‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥)

---

## ‡∏ö‡∏ó‡∏ô‡∏≥ NumPy

### NumPy ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£?
**NumPy** (Numerical Python) ‡πÄ‡∏õ‡πá‡∏ô library ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ä‡∏¥‡∏á‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‡πÉ‡∏ô Python ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏¢‡∏¥‡πà‡∏á‡πÉ‡∏ô‡∏î‡πâ‡∏≤‡∏ô Data Science, Machine Learning ‡πÅ‡∏•‡∏∞ Scientific Computing

### ‡∏ó‡∏≥‡πÑ‡∏°‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ NumPy?

#### ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö Python List vs NumPy Array

```python
# Python List - ‡∏ä‡πâ‡∏≤
python_list = [1, 2, 3, 4, 5]
result = [x * 2 for x in python_list]  # ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ loop

# NumPy Array - ‡πÄ‡∏£‡πá‡∏ß
import numpy as np
numpy_array = np.array([1, 2, 3, 4, 5])
result = numpy_array * 2  # Vectorized operation
```

### ‡∏Ç‡πâ‡∏≠‡∏î‡∏µ‡∏Ç‡∏≠‡∏á NumPy
- **Performance**: ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤ Python List ‡∏ñ‡∏∂‡∏á 50-100 ‡πÄ‡∏ó‡πà‡∏≤
- **Memory Efficient**: ‡πÉ‡∏ä‡πâ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤
- **Vectorization**: ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏±‡∏ö array ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
- **Broadcasting**: ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á array ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô
- **Integration**: ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö library ‡∏≠‡∏∑‡πà‡∏ô‡πÑ‡∏î‡πâ‡∏î‡∏µ (Pandas, Matplotlib, Scikit-learn)

### ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
- ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏á‡∏≤‡∏ô Data Science ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 95%
- Base library ‡∏Ç‡∏≠‡∏á Pandas, Scikit-learn, TensorFlow
- ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 15 ‡∏•‡πâ‡∏≤‡∏ô downloads ‡∏ï‡πà‡∏≠‡πÄ‡∏î‡∏∑‡∏≠‡∏ô

---

## ‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£ Import

### ‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á
```bash
# ‡∏ú‡πà‡∏≤‡∏ô pip
pip install numpy

# ‡∏ú‡πà‡∏≤‡∏ô conda
conda install numpy

# ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö version
python -c "import numpy; print(numpy.__version__)"
```

### ‡∏Å‡∏≤‡∏£ Import
```python
# Standard import
import numpy as np

# ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö version
print(f"NumPy version: {np.__version__}")

# Import ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
from numpy import array, zeros, ones
```

---

## NumPy Array ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô

### ndarray ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£?
**ndarray** (N-dimensional array) ‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á NumPy ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö homogeneous (‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô)

### ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á ndarray

```python
import numpy as np

# ‡∏™‡∏£‡πâ‡∏≤‡∏á array
arr = np.array([[1, 2, 3], [4, 5, 6]])

# ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
print(f"Shape: {arr.shape}")        # (2, 3)
print(f"Dimensions: {arr.ndim}")    # 2
print(f"Size: {arr.size}")          # 6
print(f"Data type: {arr.dtype}")    # int64
print(f"Item size: {arr.itemsize}") # 8 bytes
```

### Data Types ‡πÉ‡∏ô NumPy

```python
# Integer types
int8_arr = np.array([1, 2, 3], dtype=np.int8)     # 8-bit integer
int32_arr = np.array([1, 2, 3], dtype=np.int32)   # 32-bit integer
int64_arr = np.array([1, 2, 3], dtype=np.int64)   # 64-bit integer

# Float types
float32_arr = np.array([1.0, 2.0, 3.0], dtype=np.float32)
float64_arr = np.array([1.0, 2.0, 3.0], dtype=np.float64)

# Boolean type
bool_arr = np.array([True, False, True], dtype=bool)

# String type
str_arr = np.array(['a', 'b', 'c'], dtype='U1')

# ‡πÅ‡∏õ‡∏•‡∏á‡∏ä‡∏ô‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
arr_int = np.array([1.1, 2.2, 3.3])
arr_converted = arr_int.astype(int)
print(arr_converted)  # [1 2 3]
```

---

## ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Array

### ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Array

#### 1. ‡∏à‡∏≤‡∏Å Python List/Tuple
```python
# 1D Array
arr_1d = np.array([1, 2, 3, 4, 5])

# 2D Array
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])

# 3D Array
arr_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
```

#### 2. Built-in Functions
```python
# Zeros
zeros_arr = np.zeros((3, 4))           # Array ‡∏Ç‡∏≠‡∏á 0
zeros_int = np.zeros((2, 3), dtype=int) # ‡∏£‡∏∞‡∏ö‡∏∏ dtype

# Ones
ones_arr = np.ones((2, 3))             # Array ‡∏Ç‡∏≠‡∏á 1

# Empty
empty_arr = np.empty((2, 2))           # Array ‡∏ß‡πà‡∏≤‡∏á (‡∏Ñ‡πà‡∏≤ random)

# Full
full_arr = np.full((2, 3), 7)          # Array ‡πÄ‡∏ï‡πá‡∏°‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡πà‡∏≤ 7

# Identity matrix
identity = np.eye(3)                   # Identity matrix 3x3

# Range arrays
range_arr = np.arange(0, 10, 2)        # [0 2 4 6 8]
linspace_arr = np.linspace(0, 1, 5)    # [0.   0.25 0.5  0.75 1.  ]

# Random arrays
random_arr = np.random.random((2, 3))  # Random floats [0,1)
randint_arr = np.random.randint(1, 10, size=(3, 3))  # Random integers
```

#### 3. ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å Pattern
```python
# Diagonal array
diag_arr = np.diag([1, 2, 3, 4])

# Array ‡∏à‡∏≤‡∏Å function
def my_func(i, j):
    return i + j

fromfunction_arr = np.fromfunction(my_func, (3, 3))
```

---

## Array Indexing ‡πÅ‡∏•‡∏∞ Slicing

### 1D Array Indexing
```python
arr = np.array([10, 20, 30, 40, 50])

# Basic indexing
print(arr[0])     # 10 (first element)
print(arr[-1])    # 50 (last element)
print(arr[1:4])   # [20 30 40] (slicing)
print(arr[::2])   # [10 30 50] (step=2)
print(arr[::-1])  # [50 40 30 20 10] (reverse)
```

### 2D Array Indexing
```python
arr_2d = np.array([[1, 2, 3], 
                   [4, 5, 6], 
                   [7, 8, 9]])

# Basic indexing
print(arr_2d[0, 1])      # 2 (row 0, column 1)
print(arr_2d[1, :])      # [4 5 6] (entire row 1)
print(arr_2d[:, 2])      # [3 6 9] (entire column 2)
print(arr_2d[0:2, 1:3])  # [[2 3], [5 6]] (subarray)

# Negative indexing
print(arr_2d[-1, -1])    # 9 (last element)
```

### Boolean Indexing
```python
arr = np.array([1, 2, 3, 4, 5, 6])

# Boolean mask
mask = arr > 3
print(mask)              # [False False False True True True]
print(arr[mask])         # [4 5 6]

# Direct boolean indexing
print(arr[arr > 3])      # [4 5 6]
print(arr[(arr > 2) & (arr < 5)])  # [3 4] (multiple conditions)
```

### Fancy Indexing
```python
arr = np.array([10, 20, 30, 40, 50])

# Index array
indices = [0, 2, 4]
print(arr[indices])      # [10 30 50]

# 2D fancy indexing
arr_2d = np.array([[1, 2], [3, 4], [5, 6]])
print(arr_2d[[0, 2], [1, 0]])  # [2 5] (elements at (0,1) and (2,0))
```

---

## ‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≤‡∏á‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå

### Arithmetic Operations
```python
arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([5, 6, 7, 8])

# Basic operations
print(arr1 + arr2)       # [ 6  8 10 12]
print(arr1 - arr2)       # [-4 -4 -4 -4]
print(arr1 * arr2)       # [ 5 12 21 32]
print(arr1 / arr2)       # [0.2 0.33 0.43 0.5]
print(arr1 ** 2)         # [ 1  4  9 16]
print(arr1 % 2)          # [1 0 1 0]

# ‡∏Å‡∏±‡∏ö scalar
print(arr1 + 10)         # [11 12 13 14]
print(arr1 * 3)          # [ 3  6  9 12]
```

### Universal Functions (ufuncs)
```python
arr = np.array([0, np.pi/6, np.pi/4, np.pi/3, np.pi/2])

# Trigonometric functions
print(np.sin(arr))
print(np.cos(arr))
print(np.tan(arr))

# Exponential and logarithmic
arr_pos = np.array([1, 2, 3, 4, 5])
print(np.exp(arr_pos))        # e^x
print(np.log(arr_pos))        # natural log
print(np.log10(arr_pos))      # log base 10
print(np.sqrt(arr_pos))       # square root

# Other useful functions
arr_mixed = np.array([-2, -1, 0, 1, 2])
print(np.abs(arr_mixed))      # absolute value
print(np.sign(arr_mixed))     # sign function
print(np.round(np.array([1.2, 1.7, 2.3]), 0))  # rounding
```

### Comparison Operations
```python
arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([1, 3, 2, 4])

print(arr1 == arr2)      # [ True False False  True]
print(arr1 > arr2)       # [False False  True False]
print(arr1 < 3)          # [ True  True False False]

# Logical operations
print(np.logical_and(arr1 > 1, arr1 < 4))  # [False  True  True False]
print(np.logical_or(arr1 == 1, arr1 == 4)) # [ True False False  True]
print(np.logical_not(arr1 > 2))             # [ True  True False False]
```

---

## Array Manipulation

### ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á (Reshaping)
```python
arr = np.arange(12)
print(arr)                           # [ 0  1  2  3  4  5  6  7  8  9 10 11]

# Reshape
arr_2d = arr.reshape(3, 4)
print(arr_2d)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

# Reshape ‡∏Å‡∏±‡∏ö -1 (automatic calculation)
arr_auto = arr.reshape(4, -1)        # ‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á (4, 3)
arr_flat = arr_2d.reshape(-1)        # Flatten to 1D

# Transpose
arr_t = arr_2d.T                     # ‡∏´‡∏£‡∏∑‡∏≠ arr_2d.transpose()
print(arr_t.shape)                   # (4, 3)
```

### ‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏° Array (Concatenation)
```python
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])

# Concatenate along axis
concat_0 = np.concatenate([arr1, arr2], axis=0)  # ‡∏£‡∏ß‡∏°‡∏ï‡∏≤‡∏°‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á
print(concat_0)
# [[1 2]
#  [3 4]
#  [5 6]
#  [7 8]]

concat_1 = np.concatenate([arr1, arr2], axis=1)  # ‡∏£‡∏ß‡∏°‡∏ï‡∏≤‡∏°‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô
print(concat_1)
# [[1 2 5 6]
#  [3 4 7 8]]

# Stack functions
vstack_arr = np.vstack([arr1, arr2])    # ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô axis=0
hstack_arr = np.hstack([arr1, arr2])    # ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô axis=1
```

### ‡∏Å‡∏≤‡∏£‡πÅ‡∏¢‡∏Å Array (Splitting)
```python
arr = np.arange(12).reshape(3, 4)

# Split along axis
split_0 = np.split(arr, 3, axis=0)      # ‡πÅ‡∏¢‡∏Å‡πÄ‡∏õ‡πá‡∏ô 3 ‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏≤‡∏°‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á
split_1 = np.split(arr, 2, axis=1)      # ‡πÅ‡∏¢‡∏Å‡πÄ‡∏õ‡πá‡∏ô 2 ‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏≤‡∏°‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô

# Vertical and horizontal split
vsplit_arr = np.vsplit(arr, 3)          # ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á
hsplit_arr = np.hsplit(arr, 2)          # ‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô
```

### ‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°/‡∏•‡∏ö elements
```python
arr = np.array([1, 2, 3, 4, 5])

# Append
new_arr = np.append(arr, [6, 7])
print(new_arr)                          # [1 2 3 4 5 6 7]

# Insert
inserted = np.insert(arr, 2, [10, 11])  # ‡πÅ‡∏ó‡∏£‡∏Å‡∏ó‡∏µ‡πà index 2
print(inserted)                         # [ 1  2 10 11  3  4  5]

# Delete
deleted = np.delete(arr, [1, 3])        # ‡∏•‡∏ö index 1 ‡πÅ‡∏•‡∏∞ 3
print(deleted)                          # [1 3 5]
```

---

## Broadcasting

Broadcasting ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ç‡∏≠‡∏á NumPy ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á arrays ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô

### ‡∏Å‡∏é‡∏Ç‡∏≠‡∏á Broadcasting
1. Arrays ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏à‡∏±‡∏î‡πÅ‡∏ô‡∏ß (align) ‡∏à‡∏≤‡∏Å‡∏Ç‡∏ß‡∏≤‡πÑ‡∏õ‡∏ã‡πâ‡∏≤‡∏¢
2. ‡∏ñ‡πâ‡∏≤ dimension ‡πÑ‡∏°‡πà‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô ‡∏à‡∏∞‡πÄ‡∏ï‡∏¥‡∏° 1 ‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢
3. Arrays ‡∏à‡∏∞ compatible ‡∏ñ‡πâ‡∏≤ dimension ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏≠‡∏±‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô 1


### Broadcasing
‡∏Ç‡πâ‡∏≠‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á Numpy Array ‡∏Å‡∏±‡∏ö List ‡∏Ñ‡∏∑‡∏≠ Numpy Array ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ assign ‡∏Ñ‡πà‡∏≤‡∏û‡∏£‡πâ‡∏≠‡∏° ‡πÜ ‡∏Å‡∏±‡∏ô ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏•‡∏∞‡∏´‡∏•‡∏≤‡∏¢ ‡πÜ ‡∏≠‡∏á‡∏Ñ‡πå‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡πÑ‡∏î‡πâ ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏ä‡πà‡∏ô ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡∏≠‡∏á index


```python
arr[0:5]=100
arr
```




    array([100, 100, 100, 100, 100,   5,   6,   7,   8,   9,  10])



‡∏Å‡∏≤‡∏£ reset ‡∏Ñ‡πà‡∏≤ array ‡πÉ‡∏´‡∏°‡πà


```python
arr = np.arange(0,11)
arr
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10])



‡∏™‡∏£‡πâ‡∏≤‡∏á Array ‡πÉ‡∏´‡∏°‡πà ‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£ Slices


```python
slice_of_arr = arr[0:6]
slice_of_arr
```




    array([0, 1, 2, 3, 4, 5])


### ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Broadcasting
```python
# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà 1: Scalar ‡∏Å‡∏±‡∏ö Array
arr = np.array([1, 2, 3, 4])
result = arr + 10                # Broadcasting scalar
print(result)                    # [11 12 13 14]

# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà 2: 1D ‡∏Å‡∏±‡∏ö 2D
arr_2d = np.array([[1, 2, 3], 
                   [4, 5, 6]])
arr_1d = np.array([10, 20, 30])

result = arr_2d + arr_1d         # (2,3) + (3,) = (2,3)
print(result)
# [[11 22 33]
#  [14 25 36]]

# ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà 3: Column vector ‡∏Å‡∏±‡∏ö Row vector
col_vector = np.array([[1], [2], [3]])      # (3,1)
row_vector = np.array([10, 20])             # (2,)

result = col_vector + row_vector            # (3,1) + (2,) = (3,2)
print(result)
# [[11 21]
#  [12 22]
#  [13 23]]
```

### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Broadcasting ‡πÉ‡∏ô Real-world
```python
# Normalize data (subtract mean, divide by std)
data = np.random.randn(100, 5)              # 100 samples, 5 features
mean = np.mean(data, axis=0)                # Mean of each feature
std = np.std(data, axis=0)                  # Std of each feature
normalized = (data - mean) / std            # Broadcasting!

# Distance calculation
points = np.array([[1, 2], [3, 4], [5, 6]])
center = np.array([0, 0])
distances = np.sqrt(np.sum((points - center)**2, axis=1))
```

---

## ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç

### Aggregation Functions
```python
arr = np.array([[1, 2, 3], 
                [4, 5, 6], 
                [7, 8, 9]])

# Basic statistics
print(np.sum(arr))              # 45
print(np.mean(arr))             # 5.0
print(np.std(arr))              # 2.58
print(np.var(arr))              # 6.67
print(np.min(arr))              # 1
print(np.max(arr))              # 9

# Along axis
print(np.sum(arr, axis=0))      # [12 15 18] (sum columns)
print(np.sum(arr, axis=1))      # [ 6 15 24] (sum rows)
print(np.mean(arr, axis=0))     # [4. 5. 6.] (mean columns)

# Percentiles
print(np.median(arr))           # 5.0
print(np.percentile(arr, 25))   # 3.0
print(np.percentile(arr, 75))   # 7.0
```

### Sorting Functions
```python
arr = np.array([3, 1, 4, 1, 5, 9, 2, 6])

# Sort
sorted_arr = np.sort(arr)
print(sorted_arr)               # [1 1 2 3 4 5 6 9]

# Argsort (indices of sorted elements)
indices = np.argsort(arr)
print(indices)                  # [1 3 6 0 2 4 7 5]
print(arr[indices])             # [1 1 2 3 4 5 6 9]

# 2D sorting
arr_2d = np.array([[3, 2, 1], [6, 5, 4]])
print(np.sort(arr_2d, axis=1))  # Sort each row
# [[1 2 3]
#  [4 5 6]]
```

### Unique and Set Operations
```python
arr = np.array([1, 2, 2, 3, 3, 3, 4])

# Unique values
unique_vals = np.unique(arr)
print(unique_vals)              # [1 2 3 4]

# Unique with counts
unique_vals, counts = np.unique(arr, return_counts=True)
print(unique_vals)              # [1 2 3 4]
print(counts)                   # [1 2 3 1]

# Set operations
arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([3, 4, 5, 6])

print(np.intersect1d(arr1, arr2))  # [3 4] (intersection)
print(np.union1d(arr1, arr2))      # [1 2 3 4 5 6] (union)
print(np.setdiff1d(arr1, arr2))    # [1 2] (difference)
```

### Conditional Functions
```python
arr = np.array([-2, -1, 0, 1, 2])

# Where function
result = np.where(arr > 0, arr, 0)  # ‡∏ñ‡πâ‡∏≤ > 0 ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏° ‡πÑ‡∏°‡πà‡∏á‡∏±‡πâ‡∏ô‡πÉ‡∏ä‡πâ 0
print(result)                       # [0 0 0 1 2]

# Select function
conditions = [arr < -1, arr > 1]
choices = ['negative', 'positive']
result = np.select(conditions, choices, default='zero')
print(result)                       # ['negative' 'zero' 'zero' 'zero' 'positive']

# Any and All
bool_arr = np.array([True, False, True])
print(np.any(bool_arr))            # True
print(np.all(bool_arr))            # False
```

---



### Matrix Properties
```python
A = np.array([[1, 2], [3, 4]])

# Determinant
det_A = np.linalg.det(A)
print(f"Determinant: {det_A}")   # -2.0

# Inverse
inv_A = np.linalg.inv(A)
print(f"Inverse:\n{inv_A}")

# Eigenvalues and eigenvectors
eigenvals, eigenvecs = np.linalg.eig(A)
print(f"Eigenvalues: {eigenvals}")
print(f"Eigenvectors:\n{eigenvecs}")

# Matrix rank
rank_A = np.linalg.matrix_rank(A)
print(f"Rank: {rank_A}")         # 2
```

### Solving Linear Systems
```python
# Solve Ax = b
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])

x = np.linalg.solve(A, b)
print(f"Solution: {x}")          # [2. 3.]

# Verify
print(f"Verification: {A @ x}")  # [9. 8.]
```

### Decompositions
```python
A = np.array([[4, 2], [1, 3]])

# QR decomposition
Q, R = np.linalg.qr(A)
print(f"Q:\n{Q}")
print(f"R:\n{R}")

# SVD (Singular Value Decomposition)
U, s, Vt = np.linalg.svd(A)
print(f"U:\n{U}")
print(f"Singular values: {s}")
print(f"Vt:\n{Vt}")
```

---

## Random Numbers

### Random Number Generation
```python
# Set seed for reproducibility
np.random.seed(42)

# Basic random numbers
random_floats = np.random.random(5)        # [0, 1)
random_ints = np.random.randint(1, 10, 5)  # integers [1, 10)

# Random from distributions
normal_dist = np.random.normal(0, 1, 100)      # Normal(Œº=0, œÉ=1)
uniform_dist = np.random.uniform(-1, 1, 50)    # Uniform[-1, 1)
exponential_dist = np.random.exponential(2, 30) # Exponential(Œª=2)

# Random choice
arr = np.array([1, 2, 3, 4, 5])
choices = np.random.choice(arr, size=10, replace=True)

# Shuffle
data = np.arange(10)
np.random.shuffle(data)
print(data)
```

### Random Sampling
```python
# Random sampling without replacement
population = np.arange(100)
sample = np.random.choice(population, size=10, replace=False)

# Probability-based sampling
values = [1, 2, 3, 4]
probabilities = [0.4, 0.3, 0.2, 0.1]
samples = np.random.choice(values, size=1000, p=probabilities)
```

---

## File I/O

### ‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡∏∞‡πÇ‡∏´‡∏•‡∏î Array
```python
# Save and load single array
arr = np.array([1, 2, 3, 4, 5])

# Save as .npy file
np.save('my_array.npy', arr)

# Load .npy file
loaded_arr = np.load('my_array.npy')

# Save multiple arrays
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
np.savez('multiple_arrays.npz', first=arr1, second=arr2)

# Load multiple arrays
data = np.load('multiple_arrays.npz')
print(data['first'])
print(data['second'])
```

### Text Files
```python
# Save to text file
arr = np.array([[1, 2, 3], [4, 5, 6]])
np.savetxt('data.txt', arr, delimiter=',', fmt='%d')

# Load from text file
loaded_data = np.loadtxt('data.txt', delimiter=',')

# Load CSV with headers
data = np.genfromtxt('data.csv', delimiter=',', names=True, dtype=None)
```

---

## Performance ‡πÅ‡∏•‡∏∞ Memory

### Memory Layout
```python
# Row-major (C-style) vs Column-major (Fortran-style)
arr_c = np.array([[1, 2, 3], [4, 5, 6]], order='C')
arr_f = np.array([[1, 2, 3], [4, 5, 6]], order='F')

print(f"C-order flags: {arr_c.flags}")
print(f"F-order flags: {arr_f.flags}")
```

### Views vs Copies
```python
arr = np.array([1, 2, 3, 4, 5])

# View (shares memory)
view_arr = arr[1:4]
view_arr[0] = 100
print(arr)                    # [  1 100   3   4   5] - original changed!

# Copy (separate memory)
copy_arr = arr[1:4].copy()
copy_arr[0] = 200
print(arr)                    # [  1 100   3   4   5] - original unchanged
```

### Performance Tips
```python
import time

# ‡πÉ‡∏ä‡πâ vectorized operations ‡πÅ‡∏ó‡∏ô loops
n = 1000000
arr1 = np.random.random(n)
arr2 = np.random.random(n)

# Slow: Python loop
start = time.time()
result_slow = []
for i in range(n):
    result_slow.append(arr1[i] + arr2[i])
time_slow = time.time() - start

# Fast: Vectorized
start = time.time()
result_fast = arr1 + arr2
time_fast = time.time() - start

print(f"Loop time: {time_slow:.4f}s")
print(f"Vectorized time: {time_fast:.4f}s")
print(f"Speedup: {time_slow/time_fast:.1f}x")
```

---

## ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î

### ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î‡∏ó‡∏µ‡πà 1: ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô Array (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

#### ‡∏Ç‡πâ‡∏≠ 1.1 (2 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡∏™‡∏£‡πâ‡∏≤‡∏á NumPy array ‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ:
```python
# TODO: ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á array
# a) 1D array ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ [0, 2, 4, 6, 8, 10]
# b) 2D array ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö:
#    [[1, 0, 0],
#     [0, 1, 0], 
#     [0, 0, 1]]
# c) 3x4 array ‡∏ó‡∏µ‡πà‡πÄ‡∏ï‡πá‡∏°‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏•‡∏Ç 7


#### ‡∏Ç‡πâ‡∏≠ 1.2 (3 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡∏£‡∏ß‡∏à array ‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ:
```python
mystery_array = np.random.randint(1, 100, size=(5, 6))
```
‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ:
- Shape, dimensions, size, ‡πÅ‡∏•‡∏∞ data type
- ‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î, ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î, ‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢
- ‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÅ‡∏ñ‡∏ß‡πÅ‡∏•‡∏∞‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå

#### ‡∏Ç‡πâ‡∏≠ 1.3 (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á checkerboard pattern (‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏´‡∏°‡∏≤‡∏Å‡∏£‡∏∏‡∏Å) ‡∏Ç‡∏ô‡∏≤‡∏î 8x8 ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ 0 ‡πÅ‡∏•‡∏∞ 1



### ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î‡∏ó‡∏µ‡πà 2: Indexing ‡πÅ‡∏•‡∏∞ Slicing (15 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

#### ‡∏Ç‡πâ‡∏≠ 2.1 (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡∏à‡∏≤‡∏Å array ‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ:
```python
data = np.arange(1, 26).reshape(5, 5)
```
‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ô‡∏µ‡πâ:
- ‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 2 ‡πÅ‡∏•‡∏∞ 4
- ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà 1, 3, 5
- subarray ‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á 3x3
- ‡∏ó‡∏∏‡∏Å element ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 15

#### ‡∏Ç‡πâ‡∏≠ 2.2 (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö 2D array ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö:
- Border elements (elements ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏ö)
- Corner elements (elements ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏°‡∏∏‡∏°)
- Center region (‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏Ç‡∏≠‡∏ö‡∏≠‡∏≠‡∏Å 1 ‡∏ä‡∏±‡πâ‡∏ô)

### ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î‡∏ó‡∏µ‡πà 3: ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì (20 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

#### ‡∏Ç‡πâ‡∏≠ 3.1 (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì:
1. Euclidean distance ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î 2 ‡∏à‡∏∏‡∏î‡πÉ‡∏ô n-dimensional space
2. Cosine similarity ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á vector 2 ‡∏ï‡∏±‡∏ß
3. Standard score (z-score) ‡∏Ç‡∏≠‡∏á array

#### ‡∏Ç‡πâ‡∏≠ 3.2 (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡∏à‡∏≥‡∏•‡∏≠‡∏á Monte Carlo method ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡∏Ñ‡πà‡∏≤ œÄ:
1. ‡∏™‡∏∏‡πà‡∏°‡∏à‡∏∏‡∏î N ‡∏à‡∏∏‡∏î‡πÉ‡∏ô square [-1, 1] x [-1, 1]
2. ‡∏ô‡∏±‡∏ö‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô unit circle
3. ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì‡∏Ñ‡πà‡∏≤ œÄ = 4 √ó (‡∏à‡∏∏‡∏î‡πÉ‡∏ô circle / ‡∏à‡∏∏‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)

### ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î‡∏ó‡∏µ‡πà 4: Array Manipulation (15 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

#### ‡∏Ç‡πâ‡∏≠ 4.1 (8 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà:
1. ‡∏´‡∏°‡∏∏‡∏ô 2D array 90 ‡∏≠‡∏á‡∏®‡∏≤‡∏ï‡∏≤‡∏°‡πÄ‡∏Ç‡πá‡∏°‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤
2. Flip array ‡∏ï‡∏≤‡∏°‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô‡πÅ‡∏•‡∏∞‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á
3. ‡∏™‡∏£‡πâ‡∏≤‡∏á spiral array (‡πÄ‡∏•‡∏Ç‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÅ‡∏ö‡∏ö‡πÄ‡∏Å‡∏•‡∏µ‡∏¢‡∏ß)

#### ‡∏Ç‡πâ‡∏≠ 4.2 (7 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡∏à‡∏≤‡∏Å image data (2D array), ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô:
1. Crop ‡∏†‡∏≤‡∏û‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
2. Resize ‡∏†‡∏≤‡∏û‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£ sampling
3. Apply simple blur filter (3x3 averaging)

### ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î‡∏ó‡∏µ‡πà 5: Linear Algebra (20 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

#### ‡∏Ç‡πâ‡∏≠ 5.1 (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡πÅ‡∏Å‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏¥‡∏á‡πÄ‡∏™‡πâ‡∏ô:
```
3x + 2y - z = 1
2x - 2y + 4z = 0
-x + 0.5y - z = 0
```

‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö

#### ‡∏Ç‡πâ‡∏≠ 5.2 (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
Implement Principal Component Analysis (PCA) algorithm:
1. Center the data (subtract mean)
2. Calculate covariance matrix
3. Find eigenvalues and eigenvectors
4. Transform data to principal components



### ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î‡∏ó‡∏µ‡πà 6: Performance ‡πÅ‡∏•‡∏∞ Memory (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

#### ‡∏Ç‡πâ‡∏≠ 6.1 (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö performance ‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì:
1. Matrix multiplication ‡∏î‡πâ‡∏ß‡∏¢ loop vs np.dot
2. Element-wise operations ‡∏î‡πâ‡∏ß‡∏¢ loop vs vectorization
3. Sum calculation ‡∏î‡πâ‡∏ß‡∏¢ loop vs np.sum

#### ‡∏Ç‡πâ‡∏≠ 6.2 (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå memory usage:
1. ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î memory ‡∏Ç‡∏≠‡∏á Python list vs NumPy array
2. ‡∏ó‡∏î‡∏™‡∏≠‡∏ö view vs copy behavior
3. ‡∏ß‡∏±‡∏î memory footprint ‡∏Ç‡∏≠‡∏á arrays ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡πà‡∏≤‡∏á‡πÜ

### ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î‡∏ó‡∏µ‡πà 7: Practical Applications (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

#### ‡∏Ç‡πâ‡∏≠ 7.1 (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡∏™‡∏£‡πâ‡∏≤‡∏á data preprocessing pipeline:
```python
def preprocess_data(data):
    """
    Preprocess numerical data:
    1. Handle missing values (replace with mean)
    2. Remove outliers (beyond 3 standard deviations)
    3. Normalize to [0, 1] range
    4. Add polynomial features (degree 2)
    
    Parameters:
    data: np.array of shape (n_samples, n_features)
    
    Returns:
    processed_data: preprocessed data
    """
    # TODO: implement
    pass
```

#### ‡∏Ç‡πâ‡∏≠ 7.2 (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
‡∏™‡∏£‡πâ‡∏≤‡∏á simple image filters:
1. Edge detection filter
2. Sharpening filter  
3. Gaussian blur

---

## ‡πÇ‡∏Ñ‡∏£‡∏á‡∏á‡∏≤‡∏ô‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥

### ‡πÇ‡∏Ñ‡∏£‡∏á‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà 1: Weather Data Analysis (25 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

**‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢**: ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏†‡∏≤‡∏û‡∏≠‡∏≤‡∏Å‡∏≤‡∏®‡∏£‡∏≤‡∏¢‡∏ß‡∏±‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ 1 ‡∏õ‡∏µ

**‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•**: ‡∏™‡∏£‡πâ‡∏≤‡∏á synthetic weather data ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á
- Temperature (¬∞C)
- Humidity (%)
- Pressure (hPa)
- Rainfall (mm)

**‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥**:
1. **Data Generation/Loading** (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏∏‡πà‡∏°‡πÅ‡∏ö‡∏ö realistic ‡∏´‡∏£‡∏∑‡∏≠‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á
   - ‡∏à‡∏≥‡∏•‡∏≠‡∏á seasonal patterns ‡πÅ‡∏•‡∏∞ noise

2. **Data Analysis** (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (mean, std, min, max) ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
   - ‡∏´‡∏≤ correlation ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏ï‡πà‡∏≤‡∏á‡πÜ
   - ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏≤ outliers ‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£

3. **Trend Analysis** (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì moving average (7-day, 30-day)
   - ‡∏´‡∏≤ seasonal trends
   - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö long-term trends

4. **Reporting** (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå
   - ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÅ‡∏•‡∏∞ basic visualization

**Template Code**:
```python
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

def generate_weather_data(days=365):
    """Generate synthetic weather data"""
    # TODO: implement realistic weather simulation
    pass

def analyze_monthly_stats(data, dates):
    """Analyze monthly statistics"""
    # TODO: implement monthly analysis
    pass

def detect_outliers(data, threshold=3):
    """Detect outliers using z-score method"""
    # TODO: implement outlier detection
    pass

def calculate_moving_average(data, window):
    """Calculate moving average"""
    # TODO: implement moving average
    pass

# Main analysis
if __name__ == "__main__":
    # Generate or load data
    weather_data = generate_weather_data()
    
    # Perform analysis
    monthly_stats = analyze_monthly_stats(weather_data)
    outliers = detect_outliers(weather_data)
    trends = calculate_moving_average(weather_data, 30)
    
    # Generate report
    print("Weather Data Analysis Report")
    print("=" * 40)
    # TODO: implement reporting
```

### ‡πÇ‡∏Ñ‡∏£‡∏á‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà 2: Simple Recommendation System (30 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

**‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢**: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ collaborative filtering

**‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•**: User-Item rating matrix
- Users: 1000 ‡∏Ñ‡∏ô
- Items: 500 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£  
- Ratings: 1-5 (sparse matrix ~5% filled)

**‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥**:
1. **Data Generation** (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - ‡∏™‡∏£‡πâ‡∏≤‡∏á user-item rating matrix ‡πÅ‡∏ö‡∏ö sparse
   - ‡∏à‡∏≥‡∏•‡∏≠‡∏á user preferences ‡πÅ‡∏•‡∏∞ item characteristics

2. **Similarity Calculation** (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì user-user similarity (cosine similarity)
   - ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì item-item similarity
   - Handle missing values ‡πÉ‡∏ô sparse matrix

3. **Recommendation Algorithm** (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - Implement user-based collaborative filtering
   - Implement item-based collaborative filtering
   - Predict ratings ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö unrated items

4. **Evaluation** (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - Split data ‡πÄ‡∏õ‡πá‡∏ô train/test
   - ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì RMSE (Root Mean Square Error)
   - ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö performance ‡∏Ç‡∏≠‡∏á algorithms ‡∏ï‡πà‡∏≤‡∏á‡πÜ

**Template Code**:
```python
import numpy as np
from scipy.sparse import random
from sklearn.metrics.pairwise import cosine_similarity

class RecommendationSystem:
    def __init__(self, n_users=1000, n_items=500, density=0.05):
        self.n_users = n_users
        self.n_items = n_items
        self.density = density
        self.ratings = None
        
    def generate_data(self):
        """Generate synthetic user-item rating matrix"""
        # TODO: implement data generation
        pass
    
    def calculate_user_similarity(self):
        """Calculate user-user similarity matrix"""
        # TODO: implement user similarity calculation
        pass
    
    def calculate_item_similarity(self):
        """Calculate item-item similarity matrix"""
        # TODO: implement item similarity calculation
        pass
    
    def predict_user_based(self, user_id, item_id, k=50):
        """Predict rating using user-based collaborative filtering"""
        # TODO: implement user-based prediction
        pass
    
    def predict_item_based(self, user_id, item_id, k=50):
        """Predict rating using item-based collaborative filtering"""
        # TODO: implement item-based prediction
        pass
    
    def recommend_items(self, user_id, n_recommendations=10):
        """Recommend top N items for a user"""
        # TODO: implement recommendation generation
        pass
    
    def evaluate(self, test_data):
        """Evaluate recommendation system using RMSE"""
        # TODO: implement evaluation
        pass

# Example usage
if __name__ == "__main__":
    # Initialize system
    rec_sys = RecommendationSystem()
    rec_sys.generate_data()
    
    # Train model
    rec_sys.calculate_user_similarity()
    rec_sys.calculate_item_similarity()
    
    # Make recommendations
    user_id = 0
    recommendations = rec_sys.recommend_items(user_id)
    
    # Evaluate system
    rmse = rec_sys.evaluate(test_data)
    print(f"System RMSE: {rmse:.4f}")
```

### ‡πÇ‡∏Ñ‡∏£‡∏á‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà 3: Image Processing Pipeline (35 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

**‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢**: ‡∏™‡∏£‡πâ‡∏≤‡∏á image processing pipeline ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏†‡∏≤‡∏û‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô

**‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥**:
1. **Image I/O ‡πÅ‡∏•‡∏∞ Basic Operations** (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÄ‡∏õ‡πá‡∏ô NumPy array
   - Implement basic operations: crop, resize, rotate
   - Color space conversion (RGB to Grayscale)

2. **Filters ‡πÅ‡∏•‡∏∞ Enhancement** (15 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - Implement convolution operation
   - ‡∏™‡∏£‡πâ‡∏≤‡∏á filters: blur, sharpen, edge detection
   - Histogram equalization ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö contrast enhancement
   - Noise reduction filters

3. **Feature Extraction** (10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)
   - Calculate image statistics (mean, std, histogram)
   - Extract simple features: edges, corners
   - Implement simple template matching

**Template Code**:
```python
import numpy as np

class ImageProcessor:
    def __init__(self):
        pass
    
    def load_image(self, filename):
        """Load image as NumPy array"""
        # For this exercise, generate synthetic image
        # In real application, use PIL or opencv
        return np.random.randint(0, 256, (100, 100, 3), dtype=np.uint8)
    
    def rgb_to_grayscale(self, image):
        """Convert RGB image to grayscale"""
        # TODO: implement RGB to grayscale conversion
        # Formula: 0.299*R + 0.587*G + 0.114*B
        pass
    
    def crop_image(self, image, x, y, width, height):
        """Crop image to specified region"""
        # TODO: implement image cropping
        pass
    
    def resize_image(self, image, new_width, new_height):
        """Resize image using nearest neighbor interpolation"""
        # TODO: implement image resizing
        pass
    
    def apply_convolution(self, image, kernel):
        """Apply convolution filter to image"""
        # TODO: implement 2D convolution
        pass
    
    def create_blur_kernel(self, size):
        """Create averaging (blur) kernel"""
        # TODO: create blur kernel
        pass
    
    def create_edge_kernel(self):
        """Create edge detection kernel (e.g., Sobel)"""
        # TODO: create edge detection kernel
        pass
    
    def histogram_equalization(self, image):
        """Apply histogram equalization"""
        # TODO: implement histogram equalization
        pass
    
    def calculate_histogram(self, image, bins=256):
        """Calculate image histogram"""
        # TODO: implement histogram calculation
        pass
    
    def template_matching(self, image, template):
        """Find template in image using normalized cross-correlation"""
        # TODO: implement template matching
        pass

# Example pipeline
if __name__ == "__main__":
    processor = ImageProcessor()
    
    # Load and process image
    image = processor.load_image("sample.jpg")
    gray_image = processor.rgb_to_grayscale(image)
    
    # Apply filters
    blur_kernel = processor.create_blur_kernel(5)
    blurred = processor.apply_convolution(gray_image, blur_kernel)
    
    edge_kernel = processor.create_edge_kernel()
    edges = processor.apply_convolution(gray_image, edge_kernel)
    
    # Enhancement
    enhanced = processor.histogram_equalization(gray_image)
    
    # Analysis
    histogram = processor.calculate_histogram(gray_image)
    
    print("Image processing pipeline completed!")
    print(f"Original image shape: {image.shape}")
    print(f"Histogram range: {np.min(histogram)} to {np.max(histogram)}")
```

---

## ‡πÅ‡∏ô‡∏ß‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô

### ‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô

#### ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î (70%)
- **Correctness (40%)**: ‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÉ‡∏´‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
- **Code Quality (20%)**: ‡πÇ‡∏Ñ‡πâ‡∏î‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÑ‡∏î‡πâ‡∏î‡∏µ ‡∏°‡∏µ comments ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
- **Efficiency (10%)**: ‡πÉ‡∏ä‡πâ NumPy operations ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û

#### ‡πÇ‡∏Ñ‡∏£‡∏á‡∏á‡∏≤‡∏ô (30%)
- **Implementation (50%)**: implement algorithm ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô
- **Analysis (25%)**: ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÅ‡∏•‡∏∞‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÑ‡∏î‡πâ‡∏î‡∏µ
- **Documentation (15%)**: ‡∏°‡∏µ documentation ‡πÅ‡∏•‡∏∞ comments ‡∏î‡∏µ
- **Innovation (10%)**: ‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå

### ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡πÄ‡∏ï‡πá‡∏°: 100 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô
- ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î‡∏ó‡∏µ‡πà 1-7: 70 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô
- ‡πÇ‡∏Ñ‡∏£‡∏á‡∏á‡∏≤‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å 1 ‡∏à‡∏≤‡∏Å 3: 30 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô

---

## ‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°

### ‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á
1. **NumPy Official Documentation**: https://numpy.org/doc/
2. **NumPy User Guide**: https://numpy.org/doc/stable/user/
3. **NumPy API Reference**: https://numpy.org/doc/stable/reference/

### ‡∏´‡∏ô‡∏±‡∏á‡∏™‡∏∑‡∏≠‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥
1. "Python for Data Analysis" ‡πÇ‡∏î‡∏¢ Wes McKinney
2. "Effective Python" ‡πÇ‡∏î‡∏¢ Brett Slatkin  
3. "High Performance Python" ‡πÇ‡∏î‡∏¢ Micha Gorelick

### Online Courses
1. Coursera: "Introduction to Data Science in Python"
2. edX: "MIT Introduction to Computer Science and Programming"
3. Udacity: "Data Science Nanodegree"

### Practice Platforms
1. **LeetCode**: Array ‡πÅ‡∏•‡∏∞ Matrix problems
2. **HackerRank**: Python ‡πÅ‡∏•‡∏∞ Data Science tracks
3. **Kaggle Learn**: Micro-courses ‡∏ü‡∏£‡∏µ

---

## ‡∏™‡∏£‡∏∏‡∏õ

NumPy ‡πÄ‡∏õ‡πá‡∏ô foundation ‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Ç‡∏≠‡∏á Data Science ecosystem ‡πÉ‡∏ô Python ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ NumPy ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ñ‡πà‡∏≠‡∏á‡πÅ‡∏ó‡πâ‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏Å‡∏®‡∏∂‡∏Å‡∏©‡∏≤:

1. **‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ä‡∏¥‡∏á‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå**
2. **‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö libraries ‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á** (Pandas, Scikit-learn, TensorFlow)
3. **‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏ó‡∏±‡∏Å‡∏©‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û**
4. **‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Machine Learning ‡πÅ‡∏•‡∏∞ Data Science**

### ‡∏à‡∏∏‡∏î‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏≥
- **Vectorization**: ‡πÉ‡∏ä‡πâ array operations ‡πÅ‡∏ó‡∏ô loops
- **Broadcasting**: ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á arrays ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô
- **Memory efficiency**: ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à views vs copies
- **Performance**: ‡∏£‡∏π‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ NumPy vs Python built-ins

### ‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏ï‡πà‡∏≠
‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ô NumPy ‡πÅ‡∏•‡πâ‡∏ß ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏®‡∏∂‡∏Å‡∏©‡∏≤‡∏ï‡πà‡∏≠‡πÉ‡∏ô:
1. **Pandas**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö structured
2. **Matplotlib/Seaborn**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ visualization
3. **Scikit-learn**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Machine Learning
4. **TensorFlow/PyTorch**: ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Deep Learning

---

**Good luck ‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ NumPy! üöÄ**
